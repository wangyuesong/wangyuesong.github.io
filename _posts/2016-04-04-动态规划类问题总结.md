---
layout: post
category: Lintcode
title: Array类问题总结
tagline: by Archer
tags:
- Lintcode
- LeetCode
- 九章算法

---

##SubArray类问题
Array相关的问题有很多，SubArray是一大类

主要有如下几种：Subarray Sum，求某个sub array的和接近某一个值。 返回起始和终止位置

Maximum Subarray，求某个sub array的和最大，可以返回最大值或者终止起始位置

Best time to buy and sell stock,这种类型的问题不是sub array和的问题了，因为在某一个区间内，只有开始和结束两点的价格和决策有关，中间的价格不影响最后的结果

首先是这道题Subarray Sum

#### Given an integer array, find a subarray where the sum of numbers is zero. Your code should return the index of the first number and the index of the last number.


这里要用到前缀和的概念，前缀和可以表示为一个数组，prefixSum

prefixSum[i]表示正式数组中0...i个位置所有元素之和

一个subarray必然是连续的，并且subArray的sum为0的话，前缀和会有一个特征

举个例子：假设i...j的subArray的sum为0，我们可以知道的是prefixSum[i-1] == prefixSum[j]
3 1 -3 2, prefixSum[0] = prefixSum[2]

因为有-1的存在，所以prefixSum数组要有一个-1的空位，这个空位可以填入0

如果想要找到两个相等的prefixSum的index，当然可以每次产生一个新的index都和之前的index进行一下match，不过这样的效率是O(n2)

更好的办法是使用一个HashMap，以prefixSum的value作key，index做value，这样每次产生新key，只要去查找hashMap中是否存在这个key就可以了，查找效率为1，整体效率O(n)

代码如下：
{% highlight java %}
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number 
     *          and the index of the last number
     */
    public ArrayList<Integer> subarraySum(int[] nums) {
        // write your code here
       //关键在于想到Subarray sum为0的性质，
       //从index为0到sum为0的subarray开头 的 sum
       //和从index为0到sum为0的subarray的结尾 的 sum 
       //是一样的！！！
       HashMap<Integer,Integer> records = new HashMap<Integer, Integer>();
       int sum = 0;
       int step = 0;
       records.put(0,-1);
       while(step != nums.length){
           sum += nums[step];
           if(records.containsKey(sum)){
               ArrayList<Integer> returnValue = new ArrayList<Integer>();
               returnValue.add(records.get(sum) + 1);
               returnValue.add(step);
               return returnValue;
           }
           records.put(sum,step);
           step ++;
       }
       return new ArrayList<Integer>();
}
}
{% endhighlight %}

下面一题是本题升级版

#### Subarray closest:Given an integer array, find a subarray with sum closest to zero. Return the indexes of the first number and last number.

这一题同样要记录prefixSum，由于不仅仅是要找相同的prefixSum，所以hashMap已经不适用了，将prefixSum记录到一个数组中

要寻找最closeto zero的subArray，可以将prefixSum数组排序，最小的prefixSum间隔一定出现在排序后的prefixSum数组的某两个元素之间

但是不使用hashMap就没法记录index，而在这里在给prefixSum排序的过程中也需要将得到该prefixSum的位置一并记录下来，因此引入Pair这个数据结构，并且让它implements Comparable接口

prefixSum数组中要有(0,-1)这样一个初始元素

排序后，从prefixSum数组的第2个（下标1）元素开始，每个元素和之前一个元素做减法，更新global最小值和global index pair

得到global pair后，有一个问题是有可能产生这样的结果： （3，1），因为closest to zero是不分正负的，所以我们要对这个排序之后，再在第一个index上加1得到最后的结果

{% highlight java %}
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A list of integers includes the index of the first number 
     *          and the index of the last number
     */
    private class Pair implements Comparable{
        public int index;
        public int sum;
        public Pair(int index, int sum){
            this.index = index;
            this.sum = sum;
        }
        @Override
       public int compareTo(Object obj){
            return this.sum - ((Pair)obj).sum;
        }
        
    }
    public int[] subarraySumClosest(int[] nums) {
        Pair[] sumRecords = new Pair[nums.length + 1];
        sumRecords[0] = new Pair(-1,0);
        int prev = 0;
        for(int i = 0; i < nums.length; i ++){
            sumRecords[i+1] = new Pair(i, prev + nums[i]);
            prev = prev + nums[i];
        }
        Arrays.sort(sumRecords);
        int closest = Integer.MAX_VALUE;
        int[] returnValue = new int[]{0,0};
        for(int i = 1; i< sumRecords.length ; i ++){
            if(sumRecords[i].sum - sumRecords[i-1].sum < closest){
                closest = sumRecords[i].sum - sumRecords[i-1].sum;
                int[] result = new int[]{sumRecords[i].index,sumRecords[i-1].index};
                Arrays.sort(result);
                result[0] = result[0] + 1;
                returnValue = result;
            }
        }
        return returnValue;
    }    
}

{% endhighlight %}

####下一道题，maximum subarray,找到一个array中最大的subArray

同样要用到prefixSum，同样需要O(n)效率

与之前有一些不同，prefixSum这次不用存储了，我们可以记录三个全局变量，一个是max（代表走到当前位置的所有subArray的最大值，这个就是要返回的值），另一个是sum，记录到当前位置的所有元素的和，
另一个是prefixMin,这个用来记录到当前位置，前缀和的最小值在是多少。这样，每次我们走到一个位置，

(1)更新sum为sum+currentValue

(2)更新max为max和sum-prefixMin的最大值

(3)更新prefixMin为prefixMin和prefixMin + currentValue的最小值

这样最后直接返回max就可以了

当然也可以存两个数组，一个数组存sum一个数组寸prefixMin，遍历第一遍之后再重新返回遍历一边，求得sum-prefixMin的最小值

{% highlight java %}
public class Solution {
    /**
     * @param nums: A list of integers
     * @return: A integer indicate the sum of max subarray
     */
    public int maxSubArray(int[] nums) {
       if(nums.length == 1)
           return nums[0];
        // sums[0] = 0;
      
        int currentSum = 0;
        int i = 0;
        int max = Integer.MIN_VALUE;
        int prefixMin = 0;
        //在找CurrentSum过程中可以记录前缀的最小和
        while(i != nums.length){
            //加第0个
            currentSum += nums[i];
            //当前位置和减去当前位置之前的前缀和最小值
            max = Math.max(max,currentSum - prefixMin);
            //更新前缀和
            prefixMin = Math.min(prefixMin, currentSum);
            // max = Math.max(currentSum, max);
            // sums[i] = currentSum;
            i ++;
        }
        return max;
        
    }
}
{% endhighlight %}
######更新:
上一题这样的做法没有问题，但是这种解法其实是可以得到准确的subArray的，这样的思想，是将求subArray得问题转化为求两个array的差值的问题

还可以使用动态规划的思想做，因为这个题只需要返回最大的值

dp中的每一个元素代表以第i个元素结尾的（起始位置不定）的subArray的最大值

递推关系为:dp[i] = nums[i] (If dp[i-1] < 0) / nums[i] + dp[i-1] (Else)

这样可以囊括所有情况，因为所有subArray是一定会以数组中的某一个元素结尾的，同样也可以倒着traverse，代表以i元素开头的subArray


##Sell and buy stock 类问题

###### Best Time to Buy and Sell Stock

只能买卖一次

求最大获益，使用动态规划

最大获益的来源只有从低点买入，从高点卖出而得来，注意这里说的是低点和高点而非最低最高，是因为这里面不允许做空，低点一定要在高点之前出现

因此，dp的子问题为，在这i这一点前可以获利的最大值。为了获得max profit，我们还要一路记录到当前i这一点的股价最小值。这样每经过一点，就可以根据当前股价减去最小值来判断是否需要在上一个局不解的基础上更新局部解。

这一点的状态转移的方程是 dp[i] = Math.max(dp[i-1], prices[i] - minPrice);

对比subarray sum问题，状态转移方程为 dp[i] = dp[i-1] > 0 ? dp[i-1] + nums[i] : nums[i];

由于状态只和上一个状态有关，因此可以变为dp = Math.max(dp,prices[i]-minPrice);



###### Best Time to Buy and Sell Stock 2

买卖无数次，贪心

###### Best Time to Buy and Sell Stock 3

买卖两次，这个有一道类似的题，是maximum 2 subarray，这题的原理类似，都是两个方向dp

都是从两个方向划分子问题，在问题1中，由于我们最终获得的结果可以在一遍遍历的过程中得到（取各dp中的最大值），因此一维数组可以变成一个变量。

在这个问题中，每个状态定义为，从开始（结尾）到这一点，能获得的最大收益，而最终答案是由两个方向dp的某一点的和决定的，因此要保留住dp数组

###### Best time to Buy and Sell Stock 4

进行k次交易，变成二维动态规划

维护两个变量，局部最优local[i][j]，表示在第i天进行j次交易并且最后一次交易是在j天卖出的最大利润

全局最优global[i][j]，表示在第i天进行j次交易的最大利润

应该先更新局部最优解，但全局最优比较简单，先说全局

global的递推表达式比较容易，可以global[i][j] = Math.max(global[i-1][j],local[i][j]);

如果i天内买卖j次的全局的最优解包含第j天卖出的话，local[i][j]这个局部最优解就应该是这个最优解，如果不包含，一定在之前的全局最优解中

diff = prices[i] - prices[i-1];

local的递推表达式为local[i][j] = max(global[i-1][j-1] + max(0,diff), local[i-1][j] + diff);

递推表达式太难了。。没搞明白

对比背包问题，f[i][j]表示前i件物品放入j容量背包里的最大价值

###### Two sum 1

两种解题方法，一种hashMap，一种排序后双指针，排序由于会打乱原有坐标顺序，因此要建一个新的Pair，重载compareTo

###### Two Sum 2

求大于某个target的所有组合（数目），这种问题就不能使用hashMap了，还是排序后双指针，每次发现一对组合，以左右两个元素中间的所有元素为小元素也必然是一种解

###### 3 Sum
Two Sum的升级版，数组排序后，从i位置的元素开始，以i + 1 to length - 1 为范围做Two Sum1的双指针算法，效率变为o(n2)

4Sum 和这个一样

###### Triangle Count
和3Sum有些像，同样是三个指针，求数组内有多少种组合可以构成三角形，x+y>z. 不同于3Sum的固定第一个，这道题相当于要固定z（target为z，从2开始），然后在左侧的数组中寻找所有x+y>z的组合。


##### Index of permutation
o(n!)是采用dfs的效率，会超时。正确的解法是并不真正一个个遍历，而是采用数数的方式。

假设数组为[1,2,4],求的index为[2,4,1]。先看第一位，为2。那么所有1是第一位的数字组合一定都在2为第一位的组合之前出现，这样的组合有1 * 2!(24,42)种，1代表剩余可以选的数字中有几个数小于2，2表示该位后还有几位，先排除第一位。

再看第二位，为4，这时第一位已经固定为2，第二位为4的话可以知道所有第一位为2，第二位为1的数都在它的前面出现，因此又可以忽略掉1*1!个组合

同理第三位是1，可以忽略掉0个
