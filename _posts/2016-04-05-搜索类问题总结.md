---
layout: post
category: Lintcode
title: 搜索类问题总结
tagline: by Archer
tags:
- Lintcode
- LeetCode
- 九章算法

---

###### N Queens 问题

这个问题没有动态规划的解法，即使问一共有多少种解法也是，因为并不能分解成子问题

就是搜索的方法，trick在于并不用图每次传递的当前状态，而是用一个int数组，数组中第index个元素为i表示第index行的第i个位置被放上了queen

这样搜索conflict也简单，查看自己的左上，正上和右上就可以了

每一层用一个for循环recurisve或者iterative把当前层的元素全试一遍

{% highlight java %}
class Solution {
    /**
     * Get all distinct N-Queen solutions
     * @param n: The number of queens
     * @return: All distinct solutions
     * For example, A string '...Q' shows a queen on forth position
     */
    ArrayList<ArrayList<String>> solveNQueens(int n) {
        // write your code here
        LinkedList<ArrayList<Integer>> stack = new LinkedList<ArrayList<Integer>>();
        ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();
        
        for(int i = 0; i < n; i ++){
            ArrayList<Integer> initial = new ArrayList<Integer>();
            initial.add(i);
            stack.add(initial);
        }
        while(!stack.isEmpty()){
            ArrayList<Integer> current = stack.pop();
            //Get a result
            if(current.size() == n){
                result.add(new ArrayList<Integer>(current));
                continue;
            }
            //Traverse deeply
            for(int i = 0; i < n; i++){
                current.add(i);
                if(!isConfict(current, n))   
                    stack.push(new ArrayList<Integer>(current));
                current.remove(current.size()- 1);
            }
        }
        ArrayList<ArrayList<String>> stringResult = new ArrayList<ArrayList<String>>();
        for(ArrayList<Integer> oneResult: result){
            ArrayList<String> oneStringResult = new ArrayList<String>();
            for(Integer i: oneResult){
                String s = "";
                int count = 0 ;
                while(count < n){
                    if(count == i)
                        s += "Q";
                    else    
                        s += ".";
                    count ++;
                }
                oneStringResult.add(s);
            }
            stringResult.add(oneStringResult);
        }
        return stringResult;
    }
    
    public boolean isConfict(ArrayList<Integer> solution, int n){
        //Current chess
        Integer currentRowPos = solution.get(solution.size()-1);;
        int currentRow = solution.size() - 1;
        for(int i = 1; i < solution.size(); i ++){
            if(currentRow - i >= 0 && solution.get(currentRow - i) == currentRowPos - i)
                return true;
            if(currentRow - i >= 0 && solution.get(currentRow - i) == currentRowPos + i)
                return true;
            if(currentRow - i >= 0 && solution.get(currentRow - i) == currentRowPos)
                return true;
        }
        return false;
    }
};
{% endhighlight %}


非递归版本

{% highlight java %}
class Solution {
    /**
     * Calculate the total number of distinct N-Queen solutions.
     * @param n: The number of queens.
     * @return: The total number of distinct solutions.
     */
    public int totalNQueens(int n) {
        //write your code here
        int[] count = new int[1];
        ArrayList<Integer> current = new ArrayList<Integer>();
        helper(current, count, n);
        return count[0];
    }
    
    public void helper(ArrayList<Integer> current, int[] count, int totalSize){
        if(current.size() == totalSize){
            count[0] ++;
            return;
        }
        for(int i = 0 ; i < totalSize; i ++){
            current.add(i);
            if(!isConflict(current, totalSize)){
                helper(current, count, totalSize);
            }
            current.remove(current.size() - 1);
        }
    }
    
    public boolean isConflict(ArrayList<Integer> solution, int n){
        //Current chess
        Integer currentRowPos = solution.get(solution.size()-1);;
        int currentRow = solution.size() - 1;
        for(int i = 1; i < solution.size(); i ++){
            if(currentRow - i >= 0 && solution.get(currentRow - i) == currentRowPos - i)
                return true;
            if(currentRow - i >= 0 && solution.get(currentRow - i) == currentRowPos + i)
                return true;
            if(currentRow - i >= 0 && solution.get(currentRow - i) == currentRowPos)
                return true;
        }
        return false;
    }
};

{% endhighlight %}

###### Combination
同样是搜索，结束的条件是current的size == k了。

current同样从空集开始，每次递归，都遍历后面的所有元素，


##### Clone Graph
这道题和Copy Linked List with random pointer比较相近。 

Copy linked list第一种方法是多次遍历，第一次在每个节点后插入一个新节点，这样第二次遍历时，指向后面的random pointer就有地放指了

或者用个HashMap也可以

同样的，Clone graph也是要创建一个新的东西，比较简单的是遍历两次，第一次纯拷贝到HashMap中。第二次遍历时，将旧节点之间的指向关系也一起拷贝了。

也可以一次遍历完成。要采用一个HashMap<Integer,UndirectedGraphNode> visitedNodes 来记录节点的Label和新的节点之间的关系。同样用一个Queue来完成BFS。

{% highlight java %}
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     ArrayList<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public class Solution {
    /**
     * @param node: A undirected graph node
     * @return: A undirected graph node
     */
    
    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
        if(node == null)
            return null;
       
        UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);
        
        //Label -> New node
        HashMap<Integer, UndirectedGraphNode> visitedNodes = new HashMap<Integer, UndirectedGraphNode>();
        visitedNodes.put(node.label, newNode);
        
        LinkedList<UndirectedGraphNode> queue = new LinkedList<UndirectedGraphNode>();
        
        if(node.neighbors.size() == 0)
            return newNode;
            
        queue.offer(node);
        
        while(!queue.isEmpty()){
            UndirectedGraphNode current = queue.pop();
            UndirectedGraphNode currentNewNode = visitedNodes.get(current.label);
           
            for(UndirectedGraphNode neighbor: current.neighbors){
                if(visitedNodes.containsKey(neighbor.label)){

                    UndirectedGraphNode newNeighbor = visitedNodes.get(neighbor.label);
                    currentNewNode.neighbors.add(newNeighbor);
                }
                
                else{
                	//For the node that wasn't visited before(means there is not a copy of it in visitedNodes), create a copy in it
                    UndirectedGraphNode newNeighbor = new UndirectedGraphNode(neighbor.label);
                    visitedNodes.put(neighbor.label, newNeighbor);
                    // As previous, add it to current node's neighbors
                    currentNewNode.neighbors.add(newNeighbor);
                    
                    //This is for BFS, add new visited node's neighbours to queue
                    queue.offer(neighbor);
                }
            }
        }
        return newNode;
    }
}

{% endhighlight %}


